package tests.languageTests.scoping.reference1

import tests.languageTests.scoping.reference2.AnnotationInOtherPackage1
import tests.languageTests.scoping.reference2.ClassInOtherPackage1
import tests.languageTests.scoping.reference2.EnumInOtherPackage1
import tests.languageTests.scoping.reference2.globalFunctionInOtherPackage1
import tests.languageTests.scoping.reference2.InterfaceInOtherPackage1
import tests.languageTests.scoping.reference2.stepInOtherPackage1
import tests.languageTests.scoping.reference2.workflowInOtherPackage1

annotation AnnotationInSameFile

open class SuperClass {
    static attr superClassStaticAttribute: Int
    attr superClassInstanceAttribute: Int

    class ClassInSuperClass

    enum EnumInSuperClass

    static fun superClassStaticMethod()
    fun superClassInstanceMethod()

    interface InterfaceInSuperClass
}
class ClassInSameFile<TYPE_PARAMETER_IN_SAME_FILE> constructor() sub SuperClass {
    static attr classStaticAttributeInSameFile: Int
    attr classInstanceAttributeInSameFile: Int

    class ClassInClassInSameFile

    enum EnumInClassInSameFile

    static fun classStaticMethodInSameFile() -> classStaticMethodResultInSameFile: Int
    fun classInstanceMethodInSameFile() -> classInstanceMethodResultInSameFile: Int

    interface InterfaceInClassInSameFile
}

enum EnumInSameFile {
    ENUM_INSTANCE_IN_SAME_FILE
}

fun globalFunctionInSameFile(globalFunctionParameterInSameFile: Int) -> globalFunctionResultInSameFile: Int
fun globalFunctionWithOneResultWithIdenticalMember() -> result: ClassForResultMemberAccess
fun globalFunctionWithTwoResults() -> (result1: Int, result2: Int)

interface SuperInterface {
    static attr superInterfaceStaticAttribute: Int
    attr superInterfaceInstanceAttribute: Int

    class ClassInSuperInterface

    enum EnumInSuperInterface

    static fun superInterfaceStaticMethod()
    fun superInterfaceInstanceMethod()

    interface InterfaceInSuperInterface
}
interface InterfaceInSameFile sub SuperInterface {
    static attr interfaceStaticAttributeInSameFile: Int
    attr interfaceInstanceAttributeInSameFile: Int

    class ClassInInterfaceInSameFile

    enum EnumInInterfaceInSameFile

    static fun interfaceStaticMethodInSameFile() -> interfaceStaticMethodResultInSameFile: Int
    fun interfaceInstanceMethodInSameFile() -> interfaceInstanceMethodInSameFile: Int

    interface InterfaceInInterfaceInSameFile
}
fun interfaceInSameFileFactory() -> result: InterfaceInSameFile

step stepInSameFile(stepParameterInSameFile: Int) -> stepResultInSameFile: Int {
    val placeholderInSameFile = 1;
}
step stepWithOneResultWithIdenticalMember() -> result: ClassForResultMemberAccess {}
step stepWithTwoResults() -> (result1: Int, result2: Int) {}

workflow workflowInSameFile {}

interface InterfaceForOverriding {
    fun instanceMethodForOverriding()
}
open class SuperClassForOverriding constructor()
sub InterfaceForOverriding {
    attr instanceAttributeForOverriding: Int
    open override fun instanceMethodForOverriding()
}
class SubClassForOverriding constructor()
sub SuperClassForOverriding {
    attr instanceAttributeForOverriding: Int
    override fun instanceMethodForOverriding()
}

open class SuperClassForHiding {
    static attr staticAttributeForHiding: Int
    class NestedClassForHiding
    enum NestedEnumForHiding
    static fun staticMethodForHiding()
    interface NestedInterfaceForHiding
}
class SubClassForHiding sub SuperClassForHiding {
    static attr staticAttributeForHiding: Int
    class NestedClassForHiding
    enum NestedEnumForHiding
    static fun staticMethodForHiding()
    interface NestedInterfaceForHiding
}

class ClassForResultMemberAccess constructor () {
    attr result: Int
}
enum EnumForResultMemberAccess {
    result
}
interface InterfaceForResultMemberAccess {
    fun result()
}



// Direct references -----------------------------------------------------------

step directReferencesToAnnotations() {
    AnnotationInSameFile;
    AnnotationInSamePackage;
    AnnotationInOtherPackage1;
    AnnotationInOtherPackage2;
}

step directReferencesToClasses() {
    ClassInSameFile;
    ClassInSamePackage;
    ClassInOtherPackage1;
    ClassInOtherPackage2;
}

step directReferencesToEnums() {
    EnumInSameFile;
    EnumInSamePackage;
    EnumInOtherPackage1;
    EnumInOtherPackage2;
}

step directReferencesToGlobalFunctions() {
    globalFunctionInSameFile;
    globalFunctionInSamePackage;
    globalFunctionInOtherPackage1;
    globalFunctionInOtherPackage2;
}

step directReferencesToInterfaces() {
    InterfaceInSameFile;
    InterfaceInSamePackage;
    InterfaceInOtherPackage1;
    InterfaceInOtherPackage2;
}

step directReferencesToLambdaYields() {
    val f = lambda {
        yield lambdaYield = 1;
        lambdaYield;
    };
}

step directReferencesToParameters(parameterInStep: Int) {
    parameterInStep;

    val f = lambda (parameterInLambda: Int) {
        parameterInStep;
        parameterInLambda;

        val f = lambda {
            parameterInStep;
            parameterInLambda;
        };
    };
}

step directReferencesToPlaceholders() {
    val placeholderInStep = 1;
    placeholderInStep;

    val f = lambda () {
        val placeholderInLambda = 1;
        placeholderInStep;
        placeholderInLambda;

        val f = lambda {
            placeholderInStep;
            placeholderInLambda;
        };
    };
}

step directReferencesToTypeParameters() {
    TYPE_PARAMETER_IN_SAME_FILE;
}

step directReferencesToWorkflowSteps() {
    stepInSameFile;
    stepInSamePackage;
    stepInOtherPackage1;
    stepInOtherPackage2;
}

step directReferencesToWorkflows() {
    workflowInSameFile;
    workflowInSamePackage;
    workflowInOtherPackage1;
    workflowInOtherPackage2;
}

step forwardReferences() {
    a;
    val f = lambda {
        a;
        f;
    };

    val a = 1;
}

step shadowedReferences(ClassInSameFile: Int) {
    ClassInSameFile;

    val ClassInSameFile = 1;
    ClassInSameFile;

    val f = lambda (ClassInSameFile: Int) {
        ClassInSameFile;

        val ClassInSameFile = 1;
        ClassInSameFile;
    };
}

// Access to own members -------------------------------------------------------

step referencesToClassMembers() {
    ClassInSameFile.classStaticAttributeInSameFile;
    ClassInSameFile<*>().classInstanceAttributeInSameFile;
    ClassInSameFile.ClassInClassInSameFile;
    ClassInSameFile.EnumInClassInSameFile;
    ClassInSameFile.classStaticMethodInSameFile;
    ClassInSameFile<*>().classInstanceMethodInSameFile();
    ClassInSameFile.InterfaceInClassInSameFile;
}

step referencesToEnumInstances() {
    EnumInSameFile.ENUM_INSTANCE_IN_SAME_FILE;
}

step referencesToInterfaceMembers() {
    InterfaceInSameFile.interfaceStaticAttributeInSameFile;
    interfaceInSameFileFactory().interfaceInstanceAttributeInSameFile;
    InterfaceInSameFile.ClassInInterfaceInSameFile;
    InterfaceInSameFile.EnumInInterfaceInSameFile;
    InterfaceInSameFile.interfaceStaticMethodInSameFile;
    interfaceInSameFileFactory().interfaceInstanceMethodInSameFile();
    InterfaceInSameFile.InterfaceInInterfaceInSameFile;
}

// Access to inherited members -------------------------------------------------

step referencesToInheritedClassMembers() {
    ClassInSameFile.superClassStaticAttribute;
    ClassInSameFile<*>().superClassInstanceAttribute;
    ClassInSameFile.ClassInSuperClass;
    ClassInSameFile.EnumInSuperClass;
    ClassInSameFile.superClassStaticMethod;
    ClassInSameFile<*>().superClassInstanceMethod();
    ClassInSameFile.InterfaceInSuperClass;
}

step referencesToInheritedInterfaceMembers() {
    InterfaceInSameFile.superInterfaceStaticAttribute;
    interfaceInSameFileFactory().superInterfaceInstanceAttribute;
    InterfaceInSameFile.ClassInSuperInterface;
    InterfaceInSameFile.EnumInSuperInterface;
    InterfaceInSameFile.superInterfaceStaticMethod;
    interfaceInSameFileFactory().superInterfaceInstanceMethod();
    InterfaceInSameFile.InterfaceInSuperInterface;
}


// Overriding ------------------------------------------------------------------
step referencesToOverriddenMembers() {
    SuperClassForOverriding().instanceAttributeForOverriding;
    SuperClassForOverriding().instanceMethodForOverriding();

    SubClassForOverriding().instanceAttributeForOverriding;
    SubClassForOverriding().instanceMethodForOverriding();
}

// Hiding ----------------------------------------------------------------------
step referencesToHiddenMembers() {
    SubClassForHiding.staticAttributeForHiding;
    SubClassForHiding.NestedClassForHiding;
    SubClassForHiding.NestedEnumForHiding;
    SubClassForHiding.staticMethodForHiding;
    SubClassForHiding.NestedInterfaceForHiding;
}

// Access to static members from instance --------------------------------------

step referencesToStaticClassMembersFromInstance() {
    ClassInSameFile<*>().classStaticAttributeInSameFile;
    ClassInSameFile<*>().ClassInClassInSameFile;
    ClassInSameFile<*>().EnumInClassInSameFile;
    ClassInSameFile<*>().classStaticMethodInSameFile;
    ClassInSameFile<*>().InterfaceInClassInSameFile;

    ClassInSameFile<*>().superClassStaticAttribute;
    ClassInSameFile<*>().ClassInSuperClass;
    ClassInSameFile<*>().EnumInSuperClass;
    ClassInSameFile<*>().superClassStaticMethod;
    ClassInSameFile<*>().InterfaceInSuperClass;
}

step referencesToStaticInterfaceMembersFromInstance() {
    interfaceInSameFileFactory().interfaceStaticAttributeInSameFile;
    interfaceInSameFileFactory().ClassInInterfaceInSameFile;
    interfaceInSameFileFactory().EnumInInterfaceInSameFile;
    interfaceInSameFileFactory().interfaceStaticMethodInSameFile;
    interfaceInSameFileFactory().InterfaceInInterfaceInSameFile;

    interfaceInSameFileFactory().superInterfaceStaticAttribute;
    interfaceInSameFileFactory().ClassInSuperInterface;
    interfaceInSameFileFactory().EnumInSuperInterface;
    interfaceInSameFileFactory().superInterfaceStaticMethod;
    interfaceInSameFileFactory().InterfaceInSuperInterface;
}

// Access to instance members from class/interface -----------------------------

step referencesToInstanceClassMembersFromClass() {
    ClassInSameFile.classInstanceAttributeInSameFile;
    ClassInSameFile.classInstanceMethodInSameFile();

    ClassInSameFile.superClassInstanceAttribute;
    ClassInSameFile.superClassInstanceMethod();
}

step referencesToInstanceInterfaceMembersFromInterface() {
    InterfaceInSameFile.interfaceInstanceAttributeInSameFile;
    InterfaceInSameFile.interfaceInstanceMethodInSameFile();

    InterfaceInSameFile.superInterfaceInstanceAttribute;
    InterfaceInSameFile.superInterfaceInstanceMethod();
}

// Access to results of callable -----------------------------------------------

step referencesToCallableTypeResults(
    callableWithOneResult: callable () -> (singleResult: Int),
    callableWithOneResultWithIdenticalClassAttribute: callable () -> (result: ClassForResultMemberAccess),
    callableWithOneResultWithIdenticalEnumInstance: callable () -> (result: EnumForResultMemberAccess),
    callableWithOneResultWithIdenticalInterfaceMethod: callable () -> (result: InterfaceForResultMemberAccess),
    callableWithTwoResults: callable () -> (result1: Int, result2: Int)
) {
    callableWithOneResult().singleResult;
    callableWithOneResultWithIdenticalClassAttribute().result;
    callableWithOneResultWithIdenticalEnumInstance().result;
    callableWithOneResultWithIdenticalInterfaceMethod().result;
    callableWithTwoResults().result1;
}

step referencesToFunctionResults() {
    globalFunctionInSameFile(1).globalFunctionResultInSameFile;
    globalFunctionWithOneResultWithIdenticalMember().result;
    globalFunctionWithTwoResults().result1;
}

step referencesToLambdaResults() {
    val lambdaWithOneResult = lambda {
        yield singleResult = 1;
    };
    val lambdaWithOneResultWithIdenticalMember = lambda {
        yield result = ClassForResultMemberAccess();
    };
    val lambdaWithTwoResults = lambda {
        yield result1 = 1;
        yield result2 = 1;
    };
    
    lambdaWithOneResult().singleResult;
    lambdaWithOneResultWithIdenticalMember().result;
    lambdaWithTwoResults().result1;
}

step referencesToWorkflowStepResults() {
    stepInSameFile(1).stepResultInSameFile;
    stepWithOneResultWithIdenticalMember().result;
    stepWithTwoResults().result1;
}

// Access to locals from outside -----------------------------------------------

step referencesToFunctionLocals() {
    globalFunctionParameterInSameFile;
    globalFunctionResultInSameFile;
}

step referencesToLambdaLocals() {
    val f = lambda (lambdaParameter: Int) {
        val lambdaPlaceholder = 1;
        yield lambdaYield = 1;
    };

    lambdaParameter;
    lambdaPlaceholder;
    lambdaYield;
}

step referencesToWorkflowStepLocals() {
    stepParameterInSameFile;
    stepResultInSameFile;
    placeholderInSameFile;
}

// Unqualified access to members -----------------------------------------------

step unqualifiedReferencesToClassMembers() {
    classStaticAttributeInSameFile;
    classInstanceAttributeInSameFile;

    ClassInClassInSameFile;

    EnumInClassInSameFile;

    classStaticMethodInSameFile;
    classInstanceMethodInSameFile;

    InterfaceInClassInSameFile;
}

step unqualifiedReferencesToEnumInstances() {
    ENUM_INSTANCE_IN_SAME_FILE;
}

step unqualifiedReferencesToInterfaceMembers() {
    interfaceStaticAttributeInSameFile;
    interfaceInstanceAttributeInSameFile;

    ClassInInterfaceInSameFile;

    EnumInInterfaceInSameFile;

    interfaceStaticMethodInSameFile;
    interfaceInstanceMethodInSameFile;

    InterfaceInInterfaceInSameFile;
}

// Other unresolved references -------------------------------------------------

step unresolvedReferences() {
    unresolvedReference;
}
