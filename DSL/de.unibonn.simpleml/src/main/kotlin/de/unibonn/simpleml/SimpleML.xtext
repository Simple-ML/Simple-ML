grammar de.unibonn.simpleml.SimpleML hidden (
    WS,
    SL_COMMENT,
    ML_COMMENT,
    TEST_MARKER
)
import 'http://www.eclipse.org/emf/2002/Ecore' as ecore
import 'http://www.unibonn.de/simpleml/SimpleML'



/**********************************************************************************************************************
 * Declarations
 **********************************************************************************************************************/

// Compilations Units --------------------------------------------------------------------------------------------------

SmlCompilationUnit
    : {SmlCompilationUnit}
      ('package' name=QualifiedName)?
      imports+=SmlImport*
      members+=SmlCompilationUnitMember*
    ;

SmlImport
    : 'import' importedNamespace=QualifiedNameWithWildcard alias=SmlImportAlias?
    ;

SmlImportAlias
    : 'as' name=ID
    ;

SmlCompilationUnitMember returns SmlDeclaration
    : {SmlAnnotationUseHolder} annotations+=SmlAnnotationUse*

    ( {SmlAnnotation.annotationHolder=current}
          modifiers+=SmlModifier*
          'annotation' name=ID
          parameterList=SmlParameterList?

    | {SmlClass.annotationHolder=current}
          modifiers+=SmlModifier*
          'class' name=ID
          typeParameterList=SmlTypeParameterList?
          parameterList=SmlParameterList?
          parentTypeList=SmlParentTypeList?
          typeParameterConstraintList=SmlTypeParameterConstraintList?
          body=SmlClassBody?

    | {SmlEnum.annotationHolder=current}
          modifiers+=SmlModifier*
          'enum' name=ID
          body=SmlEnumBody?

    | {SmlFunction.annotationHolder=current}
          modifiers+=SmlModifier*
          'fun' name=ID
          typeParameterList=SmlTypeParameterList?
          parameterList=SmlParameterList
          resultList=SmlResultList?
          typeParameterConstraintList=SmlTypeParameterConstraintList?

    | {SmlWorkflow.annotationHolder=current}
          modifiers+=SmlModifier*
          'workflow' name=ID
          body=SmlBlock

    | {SmlWorkflowStep.annotationHolder=current}
          modifiers+=SmlModifier*
          'step' name=ID
          parameterList=SmlParameterList
          resultList=SmlWorkflowStepResultList?
          body=SmlBlock
    )
    ;


// Annotations ---------------------------------------------------------------------------------------------------------

SmlAnnotationUse
    : '@' annotation=[SmlAnnotation] argumentList=SmlAnnotationUseArgumentList?
    ;

SmlAnnotationUseArgumentList returns SmlArgumentList
    : {SmlArgumentList} '(' (arguments+=SmlAnnotationUseArgument (',' arguments+=SmlAnnotationUseArgument)* ','?)? ')'
    ;

SmlAnnotationUseArgument returns SmlArgument
    : (parameter=[SmlParameter] '=')? value=SmlExpression
    ;


// Classes -------------------------------------------------------------------------------------------------------------

SmlParentTypeList
    : 'sub' parentTypes+=SmlParentType (',' parentTypes+=SmlParentType)* ','?
    ;

SmlParentType returns SmlType
    : SmlParentPrimaryType =>({SmlMemberType.receiver=current} '.' member=SmlNamedType)*
    ;

SmlParentPrimaryType returns SmlType
    : SmlNamedType
    | SmlParentParenthesizedType
    ;

SmlParentParenthesizedType returns SmlParenthesizedType
    : '(' type=SmlParentType ')'
    ;

SmlClassBody
    : {SmlClassBody} '{' members+=SmlClassMember* '}'
    ;

SmlClassMember returns SmlDeclaration
    : {SmlAnnotationUseHolder} annotations+=SmlAnnotationUse*

    ( {SmlAttribute.annotationHolder=current}
          modifiers+=SmlModifier*
          'attr' name=ID (':' type=SmlType)?

    | {SmlClass.annotationHolder=current}
          modifiers+=SmlModifier*
          'class' name=ID
          typeParameterList=SmlTypeParameterList?
          parameterList=SmlParameterList?
          parentTypeList=SmlParentTypeList?
          typeParameterConstraintList=SmlTypeParameterConstraintList?
          body=SmlClassBody?

    | {SmlEnum.annotationHolder=current}
          modifiers+=SmlModifier*
          'enum' name=ID
          body=SmlEnumBody?

    | {SmlFunction.annotationHolder=current}
          modifiers+=SmlModifier*
          'fun' name=ID
          typeParameterList=SmlTypeParameterList?
          parameterList=SmlParameterList
          resultList=SmlResultList?
          typeParameterConstraintList=SmlTypeParameterConstraintList?
    )
    ;


// Enums ---------------------------------------------------------------------------------------------------------------

SmlEnumBody
    : {SmlEnumBody} '{' variants+=SmlEnumVariant* '}'
    ;

SmlEnumVariant
    : annotations+=SmlAnnotationUse*
      modifiers+=SmlModifier*
      name=ID
      typeParameterList=SmlTypeParameterList?
      parameterList=SmlParameterList?
      typeParameterConstraintList=SmlTypeParameterConstraintList?
    ;


// Parameters ----------------------------------------------------------------------------------------------------------

SmlParameterList
    : {SmlParameterList} '(' (parameters+=SmlParameter (',' parameters+=SmlParameter)* ','?)? ')'
    ;

SmlParameter
    : annotations+=SmlAnnotationUse*
      modifiers+=SmlModifier*
      vararg?='vararg'?
      name=ID (':' type=SmlType)?
      ('or' defaultValue=SmlExpression)?
    ;

SmlSimpleParameterList returns SmlParameterList
    : {SmlParameterList} '(' (parameters+=SmlSimpleParameter (',' parameters+=SmlSimpleParameter)* ','?)? ')'
    ;

SmlSimpleParameter returns SmlParameter
    : name=ID (':' type=SmlType)?
    ;


// Results -------------------------------------------------------------------------------------------------------------

SmlResultList
    : {SmlResultList} '->' results+=SmlResult // If there is exactly one result we need no parentheses
    | {SmlResultList} '->' '(' (results+=SmlResult (',' results+=SmlResult)* ','?)? ')'
    ;

SmlResult
    : annotations+=SmlAnnotationUse*
      modifiers+=SmlModifier*
      name=ID (':' type=SmlType)?
    ;

SmlWorkflowStepResultList returns SmlResultList
    : {SmlResultList} '->' results+=SmlWorkflowStepResult // If there is exactly one result we need no parentheses
    | {SmlResultList} '->' '(' (results+=SmlWorkflowStepResult (',' results+=SmlWorkflowStepResult)* ','?)? ')'
    ;

SmlWorkflowStepResult returns SmlResult
    : name=ID (':' type=SmlType)?
    ;



/**********************************************************************************************************************
 * Statements
 **********************************************************************************************************************/

// Functions and workflows --------------------------------------------------------------------------------------------

SmlBlock
    : {SmlBlock} '{' statements+=SmlStatement* '}'
    ;

SmlStatement
    : SmlAssignment
    | SmlExpressionStatement
    ;

SmlAssignment
    : assigneeList=SmlAssigneeList '=' expression=SmlExpression ';'
    ;

SmlAssigneeList
    : {SmlAssigneeList} assignees+=SmlAssignee
    | {SmlAssigneeList} '(' (assignees+=SmlAssignee (',' assignees+=SmlAssignee)* ','?)? ')'
    ;

SmlAssignee
    : {SmlPlaceholder} 'val' name=ID
    | {SmlWildcard}    '_'
    | {SmlYield}       'yield' result=[SmlResult]
    ;

SmlExpressionStatement
    : expression=SmlExpression ';'
    ;


// Lambdas -------------------------------------------------------------------------------------------------------------

SmlLambda
    : 'lambda'
      parameterList=SmlSimpleParameterList?
      body=SmlLambdaBlock
    ;

SmlLambdaBlock returns SmlBlock
    : {SmlBlock} '{' statements+=SmlLambdaStatement* '}'
    ;

SmlLambdaStatement returns SmlStatement
    : SmlLambdaAssignment
    | SmlExpressionStatement
    ;

SmlLambdaAssignment returns SmlAssignment
    : assigneeList=SmlLambdaAssigneeList '=' expression=SmlExpression ';'
    ;

SmlLambdaAssigneeList returns SmlAssigneeList
    : {SmlAssigneeList} assignees+=SmlLambdaAssignee
    | {SmlAssigneeList} '(' (assignees+=SmlLambdaAssignee (',' assignees+=SmlLambdaAssignee)* ','?)? ')'
    ;

SmlLambdaAssignee returns SmlAssignee
    : {SmlPlaceholder} 'val' name=ID
    | {SmlWildcard}    '_'
    | {SmlLambdaYield} 'yield' name=ID
    ;


/**********************************************************************************************************************
 * Expressions
 **********************************************************************************************************************/

SmlExpression
    : SmlOrExpression
    ;

SmlOrExpression returns SmlExpression
    : SmlAndExpression ({SmlInfixOperation.leftOperand=current} operator='or' rightOperand=SmlAndExpression)*
    ;

SmlAndExpression returns SmlExpression
    : SmlNotExpression ({SmlInfixOperation.leftOperand=current} operator='and' rightOperand=SmlNotExpression)*
    ;

SmlNotExpression returns SmlExpression
    : {SmlPrefixOperation} operator='not' operand=SmlNotExpression
    | SmlEqualityExpression
    ;

SmlEqualityExpression returns SmlExpression
    : SmlComparisonExpression ({SmlInfixOperation.leftOperand=current} operator=SmlEqualityOperator rightOperand=SmlComparisonExpression)?
    ;

SmlEqualityOperator
    : '=='
    | '!='
    | '==='
    | '!=='
    ;

SmlComparisonExpression returns SmlExpression
    : SmlAdditiveExpression ({SmlInfixOperation.leftOperand=current} operator=SmlComparisonOperator rightOperand=SmlAdditiveExpression)?
    ;

SmlComparisonOperator
    : '<'
    | '<=' 
    | '>='
    | '>'
    ;

SmlAdditiveExpression returns SmlExpression
    : SmlMultiplicativeExpression ({SmlInfixOperation.leftOperand=current} operator=SmlAdditiveOperator rightOperand=SmlMultiplicativeExpression)*
    ;

SmlAdditiveOperator
    : '+'
    | '-'
    ;

SmlMultiplicativeExpression returns SmlExpression
    : SmlElvisExpression ({SmlInfixOperation.leftOperand=current} operator=SmlMultiplicativeOperator rightOperand=SmlElvisExpression)*
    ;

SmlMultiplicativeOperator
    : '*'
    | '/'
    ;

SmlElvisExpression returns SmlExpression
    : SmlUnaryOperation ({SmlInfixOperation.leftOperand=current} operator='?:' rightOperand=SmlUnaryOperation)*
    ;

SmlUnaryOperation returns SmlExpression
    : {SmlPrefixOperation} operator='-' operand=SmlUnaryOperation
    | SmlChainedExpression
    ;

SmlChainedExpression returns SmlExpression
    : SmlPrimaryExpression =>(
          {SmlCall.receiver=current}          typeArgumentList=SmlTypeArgumentList? argumentList=SmlCallArgumentList
        | {SmlMemberAccess.receiver=current}  (nullable?='?')? '.' member=SmlReference
    )*
    ;

SmlCallArgumentList returns SmlArgumentList
    : {SmlArgumentList} '(' (arguments+=SmlCallArgument (',' arguments+=SmlCallArgument)* ','?)? ')'
    ;

SmlCallArgument returns SmlArgument
    : (parameter=[SmlParameter] '=')? value=SmlExpression
    ;

SmlPrimaryExpression returns SmlExpression
    : SmlLambda
    | SmlLiteral
    | SmlParenthesizedExpression
    | SmlReference
    | SmlTemplateString
    ;

SmlLiteral
    : SmlBoolean
    | SmlFloat
    | SmlInt
    | SmlNull
    | SmlString
    ;    

SmlBoolean
    : true?='true'
    | {SmlBoolean} 'false'
    ;

SmlFloat
    : value=FLOAT
    ;

SmlInt
    : value=INT
    ;

SmlNull
    : {SmlNull} 'null'
    ;

SmlString
    : value=STRING
    ;

SmlTemplateString
    : expressions+=SmlTemplateStringStart expressions+=SmlExpression?
      (expressions+=SmlTemplateStringInbetween expressions+=SmlExpression?)*
      expressions+=SmlTemplateStringEnd
    ;

SmlTemplateStringStart returns SmlTemplateStringPart
    : value=TEMPLATE_STRING_START
    ;

SmlTemplateStringInbetween returns SmlTemplateStringPart
    : value=TEMPLATE_STRING_INBETWEEN
    ;

SmlTemplateStringEnd returns SmlTemplateStringPart
    : value=TEMPLATE_STRING_END
    ;

SmlReference
    : declaration=[SmlDeclaration]
    ;

SmlParenthesizedExpression
    : '(' expression=SmlExpression ')'
    ;



/**********************************************************************************************************************
 * Modifiers
 **********************************************************************************************************************/

SmlModifier
    : 'open'
    | 'override'
    | 'static'
    ;



/**********************************************************************************************************************
 * Names
 **********************************************************************************************************************/

QualifiedName
    : ID ('.' ID)*
    ;

QualifiedNameWithWildcard
    : QualifiedName '.*'?
    ;



/**********************************************************************************************************************
 * Types
 **********************************************************************************************************************/

SmlType
    : SmlPrimaryType =>({SmlMemberType.receiver=current} '.' member=SmlNamedType)*
    ;

SmlPrimaryType returns SmlType
    : SmlCallableType
    | SmlNamedType
    | SmlUnionType
    | SmlParenthesizedType
    ;

SmlParenthesizedType
    : '(' type=SmlType ')'
    ;

// Callable Types ------------------------------------------------------------------------------------------------------

SmlCallableType
    : 'callable'
      parameterList=SmlParameterList
      resultList=SmlResultList
    ;


// Named Types ---------------------------------------------------------------------------------------------------------

SmlNamedType
    : declaration=[SmlNamedTypeDeclaration]
      typeArgumentList=SmlTypeArgumentList?
      (nullable?='?')?
    ;


// Union Types ---------------------------------------------------------------------------------------------------------

SmlUnionType
    : 'union' typeArgumentList=SmlUnionTypeArgumentList
    ;

SmlUnionTypeArgumentList returns SmlTypeArgumentList
    : {SmlTypeArgumentList} ('<' (typeArguments+=SmlUnionTypeArgument (',' typeArguments+=SmlUnionTypeArgument)* ','?)? '>')
    ;

SmlUnionTypeArgument returns SmlTypeArgument
    : value=SmlUnionTypeArgumentValue
    ;

SmlUnionTypeArgumentValue returns SmlTypeArgumentValue
    : {SmlTypeProjection} type=SmlType
    ;


// Generics ------------------------------------------------------------------------------------------------------------

SmlTypeParameterList
    : {SmlTypeParameterList} ('<' (typeParameters+=SmlTypeParameter (',' typeParameters+=SmlTypeParameter)* ','?)? '>')
    ;

SmlTypeParameter
    : annotations+=SmlAnnotationUse*
      modifiers+=SmlModifier*
      variance=SmlTypeParameterVariance?
      name=ID
    ;

SmlTypeParameterVariance
    : 'in'
    | 'out'
    ;

SmlTypeParameterConstraintList
    : 'where' constraints+=SmlTypeParameterConstraint (',' constraints+=SmlTypeParameterConstraint)* ','?
    ;

SmlTypeParameterConstraint
    : leftOperand=[SmlTypeParameter] operator=SmlTypeParameterConstraintOperator rightOperand=SmlType
    ;

SmlTypeParameterConstraintOperator
    : 'sub'
    | 'super'
    ;

SmlTypeArgumentList
    : {SmlTypeArgumentList} '<' (typeArguments+=SmlTypeArgument (',' typeArguments+=SmlTypeArgument)* ','?)? '>'
    ;

SmlTypeArgument
    : (typeParameter=[SmlTypeParameter] '=')? value=SmlTypeArgumentValue
    ;

SmlTypeArgumentValue
    : {SmlStarProjection} '*'
    | {SmlTypeProjection} variance=SmlTypeParameterVariance? type=SmlType
    ;



/**********************************************************************************************************************
 * Terminals
 **********************************************************************************************************************/

terminal FLOAT returns ecore::EDouble
    : DECIMAL_DIGIT+ '.' DECIMAL_DIGIT+ FLOAT_EXPONENT?
    | DECIMAL_DIGIT+ FLOAT_EXPONENT
    ;

terminal fragment DECIMAL_DIGIT
    : '0'..'9'
    ;

terminal fragment FLOAT_EXPONENT
    : ('e'|'E') ('+'|'-')? DECIMAL_DIGIT+
    ;

terminal ID
    : ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
    ;

terminal INT returns ecore::EInt
    : DECIMAL_DIGIT+
    ;

terminal ML_COMMENT
    : '/*' -> '*/'
    ;

terminal SL_COMMENT
    : '//' !('\r'|'\n')* ('\r'? '\n')?
    ;

terminal STRING
    : STRING_DELIMITER
      STRING_TEXT*
      STRING_DELIMITER
    ;

terminal fragment STRING_DELIMITER
    : '"'
    ;

terminal fragment STRING_TEXT
    : ESCAPE_SEQUENCE
    | '{' !'{'
    | !('\\'|STRING_DELIMITER|'{')
    ;

terminal fragment ESCAPE_SEQUENCE
    : '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */
    ;

terminal fragment TEMPLATE_EXPRESSION_START
    : '{{'
    ;

terminal fragment TEMPLATE_EXPRESSION_END
    : '}}'
    ;

terminal TEMPLATE_STRING_START
    : STRING_DELIMITER
      STRING_TEXT*
      TEMPLATE_EXPRESSION_START
    ;

terminal TEMPLATE_STRING_INBETWEEN
    : TEMPLATE_EXPRESSION_END
      STRING_TEXT*
      TEMPLATE_EXPRESSION_START
    ;

terminal TEMPLATE_STRING_END
    : TEMPLATE_EXPRESSION_END
      STRING_TEXT*
      STRING_DELIMITER
    ;

terminal TEST_MARKER
    : '»'
    | '«'
    ;

terminal WS
    : (' '|'\t'|'\r'|'\n')+
    ;
