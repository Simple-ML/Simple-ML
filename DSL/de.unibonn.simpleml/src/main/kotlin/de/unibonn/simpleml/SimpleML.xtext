grammar de.unibonn.simpleml.SimpleML hidden (
    WS,
    SL_COMMENT,
    ML_COMMENT,
    TEST_MARKER
)
import 'http://www.eclipse.org/emf/2002/Ecore' as ecore
import 'http://www.unibonn.de/simpleml/SimpleML'



/**********************************************************************************************************************
 * Declarations
 **********************************************************************************************************************/

// Compilations Units --------------------------------------------------------------------------------------------------

SmlCompilationUnit
    : {SmlCompilationUnit} members+=SmlCompilationUnitMember*
    ;

SmlCompilationUnitMember returns SmlAbstractAnnotatedObject
    : {SmlAnnotationUseHolder} annotations+=SmlAnnotationUse*

    ( {SmlPackage.annotationUseHolder=current}
          ( ('package' name=QualifiedName =>imports+=SmlImport*)
          | (imports+=SmlImport =>imports+=SmlImport*)
          )
          =>members+=SmlPackageMember*

    | {SmlAnnotation.annotationUseHolder=current}
          'annotation' name=ID
          parameterList=SmlParameterList?
          constraintList=SmlConstraintList?

    | {SmlClass.annotationUseHolder=current}
          'class' name=ID
          typeParameterList=SmlTypeParameterList?
          parameterList=SmlParameterList?
          parentTypeList=SmlParentTypeList?
          constraintList=SmlConstraintList?
          body=SmlClassBody?

    | {SmlEnum.annotationUseHolder=current}
          'enum' name=ID
          body=SmlEnumBody?

    | {SmlFunction.annotationUseHolder=current}
          'fun' name=ID
          typeParameterList=SmlTypeParameterList?
          parameterList=SmlParameterList
          resultList=SmlResultList?
          constraintList=SmlConstraintList?

    | {SmlWorkflow.annotationUseHolder=current}
          'workflow' name=ID
          body=SmlBlock

    | {SmlWorkflowStep.annotationUseHolder=current}
          'step' name=ID
          parameterList=SmlParameterList
          resultList=SmlWorkflowStepResultList?
          body=SmlBlock
    )
    ;

SmlImport
    : 'import' importedNamespace=QualifiedNameWithWildcard alias=SmlImportAlias?
    ;

SmlImportAlias
    : 'as' name=ID
    ;

SmlPackageMember returns SmlAbstractAnnotatedObject
    : {SmlAnnotationUseHolder} annotations+=SmlAnnotationUse*

    ( {SmlAnnotation.annotationUseHolder=current}
          'annotation' name=ID
          parameterList=SmlParameterList?
          constraintList=SmlConstraintList?

    | {SmlClass.annotationUseHolder=current}
          'class' name=ID
          typeParameterList=SmlTypeParameterList?
          parameterList=SmlParameterList?
          parentTypeList=SmlParentTypeList?
          constraintList=SmlConstraintList?
          body=SmlClassBody?

    | {SmlEnum.annotationUseHolder=current}
          'enum' name=ID
          body=SmlEnumBody?

    | {SmlFunction.annotationUseHolder=current}
          'fun' name=ID
          typeParameterList=SmlTypeParameterList?
          parameterList=SmlParameterList
          resultList=SmlResultList?
          constraintList=SmlConstraintList?

    | {SmlWorkflow.annotationUseHolder=current}
          'workflow' name=ID
          body=SmlBlock

    | {SmlWorkflowStep.annotationUseHolder=current}
          'step' name=ID
          parameterList=SmlParameterList
          resultList=SmlWorkflowStepResultList?
          body=SmlBlock
    )
    ;


// Annotations ---------------------------------------------------------------------------------------------------------

SmlAnnotationUse
    : '@' annotation=[SmlAnnotation] argumentList=SmlAnnotationUseArgumentList?
    ;

SmlAnnotationUseArgumentList returns SmlArgumentList
    : {SmlArgumentList} '(' (arguments+=SmlAnnotationUseArgument (',' arguments+=SmlAnnotationUseArgument)* ','?)? ')'
    ;

SmlAnnotationUseArgument returns SmlArgument
    : (parameter=[SmlParameter] '=')? value=SmlExpression
    ;


// Classes -------------------------------------------------------------------------------------------------------------

SmlParentTypeList
    : 'sub' parentTypes+=SmlParentType (',' parentTypes+=SmlParentType)* ','?
    ;

SmlParentType returns SmlAbstractType
    : SmlParentPrimaryType =>({SmlMemberType.receiver=current} '.' member=SmlNamedType)*
    ;

SmlParentPrimaryType returns SmlAbstractType
    : SmlNamedType
    | SmlParentParenthesizedType
    ;

SmlParentParenthesizedType returns SmlParenthesizedType
    : '(' type=SmlParentType ')'
    ;

SmlClassBody
    : {SmlClassBody} '{' members+=SmlClassMember* '}'
    ;

SmlClassMember returns SmlAbstractObject
    : SmlAnnotatedClassMember
    | SmlBehaviorProtocol
    ;

SmlAnnotatedClassMember returns SmlAbstractAnnotatedObject
    : {SmlAnnotationUseHolder} annotations+=SmlAnnotationUse*

    ( {SmlAttribute.annotationUseHolder=current}
          static?='static'?
          'attr' name=ID (':' type=SmlType)?

    | {SmlClass.annotationUseHolder=current}
          'class' name=ID
          typeParameterList=SmlTypeParameterList?
          parameterList=SmlParameterList?
          parentTypeList=SmlParentTypeList?
          constraintList=SmlConstraintList?
          body=SmlClassBody?

    | {SmlEnum.annotationUseHolder=current}
          'enum' name=ID
          body=SmlEnumBody?

    | {SmlFunction.annotationUseHolder=current}
          static?='static'?
          'fun' name=ID
          typeParameterList=SmlTypeParameterList?
          parameterList=SmlParameterList
          resultList=SmlResultList?
          constraintList=SmlConstraintList?
    )
    ;

SmlBehaviorProtocol
    : 'protocol' body=SmlBehaviorProtocolBody
    ;

SmlBehaviorProtocolBody
    : {SmlBehaviorProtocolBody} '{' element=SmlBehaviorProtocolElement? '}'
    ;

SmlBehaviorProtocolElement returns SmlAbstractBehaviorProtocolElement
    : SmlBehaviorProtocolAlternative
    ;

SmlBehaviorProtocolAlternative returns SmlAbstractBehaviorProtocolElement
    : SmlBehaviorProtocolSequence
    (
        {SmlBehaviorProtocolAlternative.elements+=current} '|' elements+=SmlBehaviorProtocolSequence
        ('|' elements+=SmlBehaviorProtocolSequence)*
    )?
    ;

SmlBehaviorProtocolSequence returns SmlAbstractBehaviorProtocolElement
    : SmlBehaviorProtocolQuantifiedElement
      ({SmlBehaviorProtocolSequence.elements+=current} elements+=SmlBehaviorProtocolQuantifiedElement*)
    ;

SmlBehaviorProtocolQuantifiedElement returns SmlAbstractBehaviorProtocolQuantifiedElement
    : SmlBehaviorProtocolPrimaryElement
      ({SmlProtocolQuantifiedElement.element=current} quantifier=SmlBehaviorProtocolQuantifier)?
    ;

SmlBehaviorProtocolPrimaryElement returns SmlAbstractBehaviorProtocolElement
    : SmlBehaviorProtocolReference
    | SmlBehaviorProtocolParenthesizedElement
    ;

// TODO: SmlBehaviorProtocol -> SmlProtocol
// TODO: SmlWorkflowStep -> SmlStep
// TODO: quantified element es postfix operator
// TODO: difference
// TODO: subprotocols
// TODO: token classes
// todo: call elements terms

SmlBehaviorProtocolToken
    : declaration=[SmlAbstractClassMember]
    ;

SmlBehaviorProtocolParenthesizedElement
    : '(' element=SmlBehaviorProtocolElement ')'
    ;

SmlBehaviorProtocolQuantifier
    : '?'
    | '*'
    | '+'
    ;


// Enums ---------------------------------------------------------------------------------------------------------------

SmlEnumBody
    : {SmlEnumBody} '{' variants+=SmlEnumVariant* '}'
    ;

SmlEnumVariant
    : annotations+=SmlAnnotationUse*
      name=ID
      typeParameterList=SmlTypeParameterList?
      parameterList=SmlParameterList?
      constraintList=SmlConstraintList?
    ;


// Parameters ----------------------------------------------------------------------------------------------------------

SmlParameterList
    : {SmlParameterList} '(' (parameters+=SmlParameter (',' parameters+=SmlParameter)* ','?)? ')'
    ;

SmlParameter
    : annotations+=SmlAnnotationUse*
      variadic?='vararg'?
      name=ID (':' type=SmlType)?
      ('or' defaultValue=SmlExpression)?
    ;

SmlSimpleParameterList returns SmlParameterList
    : {SmlParameterList} '(' (parameters+=SmlSimpleParameter (',' parameters+=SmlSimpleParameter)* ','?)? ')'
    ;

SmlSimpleParameter returns SmlParameter
    : name=ID (':' type=SmlType)?
    ;


// Results -------------------------------------------------------------------------------------------------------------

SmlResultList
    : {SmlResultList} '->' results+=SmlResult // If there is exactly one result we need no parentheses
    | {SmlResultList} '->' '(' (results+=SmlResult (',' results+=SmlResult)* ','?)? ')'
    ;

SmlResult
    : annotations+=SmlAnnotationUse*
      name=ID (':' type=SmlType)?
    ;

SmlWorkflowStepResultList returns SmlResultList
    : {SmlResultList} '->' results+=SmlWorkflowStepResult // If there is exactly one result we need no parentheses
    | {SmlResultList} '->' '(' (results+=SmlWorkflowStepResult (',' results+=SmlWorkflowStepResult)* ','?)? ')'
    ;

SmlWorkflowStepResult returns SmlResult
    : name=ID (':' type=SmlType)?
    ;



/**********************************************************************************************************************
 * Statements
 **********************************************************************************************************************/

// Functions and workflows --------------------------------------------------------------------------------------------

SmlBlock
    : {SmlBlock} '{' statements+=SmlStatement* '}'
    ;

SmlStatement returns SmlAbstractStatement
    : SmlAssignment
    | SmlExpressionStatement
    ;

SmlAssignment
    : assigneeList=SmlAssigneeList '=' expression=SmlExpression ';'
    ;

SmlAssigneeList
    : {SmlAssigneeList} assignees+=SmlAssignee
    | {SmlAssigneeList} '(' (assignees+=SmlAssignee (',' assignees+=SmlAssignee)* ','?)? ')'
    ;

SmlAssignee returns SmlAbstractAssignee
    : {SmlPlaceholder} annotations+=SmlAnnotationUse* 'val' name=ID
    | {SmlWildcard}    '_'
    | {SmlYield}       'yield' result=[SmlResult]
    ;

SmlExpressionStatement
    : expression=SmlExpression ';'
    ;


// Lambdas -------------------------------------------------------------------------------------------------------------

SmlLambda
    : 'lambda'
      parameterList=SmlSimpleParameterList?
      body=SmlLambdaBlock
    ;

SmlLambdaBlock returns SmlBlock
    : {SmlBlock} '{' statements+=SmlLambdaStatement* '}'
    ;

SmlLambdaStatement returns SmlAbstractStatement
    : SmlLambdaAssignment
    | SmlExpressionStatement
    ;

SmlLambdaAssignment returns SmlAssignment
    : assigneeList=SmlLambdaAssigneeList '=' expression=SmlExpression ';'
    ;

SmlLambdaAssigneeList returns SmlAssigneeList
    : {SmlAssigneeList} assignees+=SmlLambdaAssignee
    | {SmlAssigneeList} '(' (assignees+=SmlLambdaAssignee (',' assignees+=SmlLambdaAssignee)* ','?)? ')'
    ;

SmlLambdaAssignee returns SmlAbstractAnnotatedObject
    : {SmlWildcard} '_'
    |
    ( {SmlAnnotationUseHolder} annotations+=SmlAnnotationUse*
        ( {SmlPlaceholder.annotationUseHolder=current} 'val' name=ID
        | {SmlLambdaResult.annotationUseHolder=current} 'yield' name=ID
        )
    )
    ;


/**********************************************************************************************************************
 * Expressions
 **********************************************************************************************************************/

SmlExpression returns SmlAbstractExpression
    : SmlOrExpression
    ;

SmlOrExpression returns SmlAbstractExpression
    : SmlAndExpression ({SmlInfixOperation.leftOperand=current} operator='or' rightOperand=SmlAndExpression)*
    ;

SmlAndExpression returns SmlAbstractExpression
    : SmlNotExpression ({SmlInfixOperation.leftOperand=current} operator='and' rightOperand=SmlNotExpression)*
    ;

SmlNotExpression returns SmlAbstractExpression
    : {SmlPrefixOperation} operator='not' operand=SmlNotExpression
    | SmlEqualityExpression
    ;

SmlEqualityExpression returns SmlAbstractExpression
    : SmlComparisonExpression ({SmlInfixOperation.leftOperand=current} operator=SmlEqualityOperator rightOperand=SmlComparisonExpression)?
    ;

SmlEqualityOperator
    : '=='
    | '!='
    | '==='
    | '!=='
    ;

SmlComparisonExpression returns SmlAbstractExpression
    : SmlAdditiveExpression ({SmlInfixOperation.leftOperand=current} operator=SmlComparisonOperator rightOperand=SmlAdditiveExpression)?
    ;

SmlComparisonOperator
    : '<'
    | '<=' 
    | '>='
    | '>'
    ;

SmlAdditiveExpression returns SmlAbstractExpression
    : SmlMultiplicativeExpression ({SmlInfixOperation.leftOperand=current} operator=SmlAdditiveOperator rightOperand=SmlMultiplicativeExpression)*
    ;

SmlAdditiveOperator
    : '+'
    | '-'
    ;

SmlMultiplicativeExpression returns SmlAbstractExpression
    : SmlElvisExpression ({SmlInfixOperation.leftOperand=current} operator=SmlMultiplicativeOperator rightOperand=SmlElvisExpression)*
    ;

SmlMultiplicativeOperator
    : '*'
    | '/'
    ;

SmlElvisExpression returns SmlAbstractExpression
    : SmlUnaryOperation ({SmlInfixOperation.leftOperand=current} operator='?:' rightOperand=SmlUnaryOperation)*
    ;

SmlUnaryOperation returns SmlAbstractExpression
    : {SmlPrefixOperation} operator='-' operand=SmlUnaryOperation
    | SmlChainedExpression
    ;

SmlChainedExpression returns SmlAbstractExpression
    : SmlPrimaryExpression =>(
          {SmlCall.receiver=current}          typeArgumentList=SmlTypeArgumentList? argumentList=SmlCallArgumentList
        | {SmlMemberAccess.receiver=current}  (nullSafe?='?')? '.' member=SmlReference
    )*
    ;

SmlCallArgumentList returns SmlArgumentList
    : {SmlArgumentList} '(' (arguments+=SmlCallArgument (',' arguments+=SmlCallArgument)* ','?)? ')'
    ;

SmlCallArgument returns SmlArgument
    : (parameter=[SmlParameter] '=')? value=SmlExpression
    ;

SmlPrimaryExpression returns SmlAbstractExpression
    : SmlLambda
    | SmlLiteral
    | SmlParenthesizedExpression
    | SmlReference
    | SmlTemplateString
    ;

SmlLiteral returns SmlAbstractLiteral
    : SmlBoolean
    | SmlFloat
    | SmlInt
    | SmlNull
    | SmlString
    ;    

SmlBoolean
    : true?='true'
    | {SmlBoolean} 'false'
    ;

SmlFloat
    : value=FLOAT
    ;

SmlInt
    : value=INT
    ;

SmlNull
    : {SmlNull} 'null'
    ;

SmlString
    : value=STRING
    ;

SmlTemplateString
    : expressions+=SmlTemplateStringStart expressions+=SmlExpression?
      (expressions+=SmlTemplateStringInner expressions+=SmlExpression?)*
      expressions+=SmlTemplateStringEnd
    ;

SmlTemplateStringStart
    : value=TEMPLATE_STRING_START
    ;

SmlTemplateStringInner
    : value=TEMPLATE_STRING_INNER
    ;

SmlTemplateStringEnd
    : value=TEMPLATE_STRING_END
    ;

SmlReference
    : declaration=[SmlAbstractDeclaration]
    ;

SmlParenthesizedExpression
    : '(' expression=SmlExpression ')'
    ;



/**********************************************************************************************************************
 * Names
 **********************************************************************************************************************/

QualifiedName
    : ID ('.' ID)*
    ;

QualifiedNameWithWildcard
    : QualifiedName '.*'?
    ;



/**********************************************************************************************************************
 * Types
 **********************************************************************************************************************/

SmlType returns SmlAbstractType
    : SmlPrimaryType =>({SmlMemberType.receiver=current} '.' member=SmlNamedType)*
    ;

SmlPrimaryType returns SmlAbstractType
    : SmlCallableType
    | SmlNamedType
    | SmlUnionType
    | SmlParenthesizedType
    ;

SmlParenthesizedType
    : '(' type=SmlType ')'
    ;

// Callable Types ------------------------------------------------------------------------------------------------------

SmlCallableType
    : 'callable'
      parameterList=SmlParameterList
      resultList=SmlResultList
    ;


// Named Types ---------------------------------------------------------------------------------------------------------

SmlNamedType
    : declaration=[SmlAbstractNamedTypeDeclaration]
      typeArgumentList=SmlTypeArgumentList?
      (nullable?='?')?
    ;


// Union Types ---------------------------------------------------------------------------------------------------------

SmlUnionType
    : 'union' typeArgumentList=SmlUnionTypeArgumentList
    ;

SmlUnionTypeArgumentList returns SmlTypeArgumentList
    : {SmlTypeArgumentList} ('<' (typeArguments+=SmlUnionTypeArgument (',' typeArguments+=SmlUnionTypeArgument)* ','?)? '>')
    ;

SmlUnionTypeArgument returns SmlTypeArgument
    : value=SmlUnionTypeArgumentValue
    ;

SmlUnionTypeArgumentValue returns SmlAbstractTypeArgumentValue
    : {SmlTypeProjection} type=SmlType
    ;


// Generics ------------------------------------------------------------------------------------------------------------

SmlTypeParameterList
    : {SmlTypeParameterList} ('<' (typeParameters+=SmlTypeParameter (',' typeParameters+=SmlTypeParameter)* ','?)? '>')
    ;

SmlTypeParameter
    : annotations+=SmlAnnotationUse*
      variance=SmlTypeParameterVariance?
      name=ID
    ;

SmlTypeParameterVariance
    : 'in'
    | 'out'
    ;

SmlConstraintList
    : 'where' constraints+=SmlTypeParameterConstraint (',' constraints+=SmlTypeParameterConstraint)* ','?
    ;

SmlTypeParameterConstraint
    : leftOperand=[SmlTypeParameter] operator=SmlTypeParameterConstraintOperator rightOperand=SmlType
    ;

SmlTypeParameterConstraintOperator
    : 'sub'
    | 'super'
    ;

SmlTypeArgumentList
    : {SmlTypeArgumentList} '<' (typeArguments+=SmlTypeArgument (',' typeArguments+=SmlTypeArgument)* ','?)? '>'
    ;

SmlTypeArgument
    : (typeParameter=[SmlTypeParameter] '=')? value=SmlTypeArgumentValue
    ;

SmlTypeArgumentValue returns SmlAbstractTypeArgumentValue
    : {SmlStarProjection} '*'
    | {SmlTypeProjection} variance=SmlTypeParameterVariance? type=SmlType
    ;



/**********************************************************************************************************************
 * Terminals
 **********************************************************************************************************************/

terminal FLOAT returns ecore::EDouble
    : DECIMAL_DIGIT+ '.' DECIMAL_DIGIT+ FLOAT_EXPONENT?
    | DECIMAL_DIGIT+ FLOAT_EXPONENT
    ;

terminal fragment DECIMAL_DIGIT
    : '0'..'9'
    ;

terminal fragment FLOAT_EXPONENT
    : ('e'|'E') ('+'|'-')? DECIMAL_DIGIT+
    ;

terminal ID
    : IDENTIFIER
    | '`' IDENTIFIER '`'
    ;

terminal fragment IDENTIFIER
    : ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
    ;

terminal INT returns ecore::EInt
    : DECIMAL_DIGIT+
    ;

terminal ML_COMMENT
    : '/*' -> '*/'
    ;

terminal SL_COMMENT
    : '//' !('\r'|'\n')* ('\r'? '\n')?
    ;

terminal STRING returns ecore::EString
    : STRING_START
      STRING_TEXT*
      STRING_END
    ;

terminal fragment STRING_START
    : STRING_DELIMITER
    ;

terminal fragment STRING_END
    : '{'? STRING_DELIMITER
    ;

terminal fragment STRING_DELIMITER
    : '"'
    ;

terminal fragment STRING_TEXT
    : '{'? ESCAPE_SEQUENCE
    | '{'? !('\\'|STRING_DELIMITER|'{')
    ;

terminal fragment ESCAPE_SEQUENCE
    : '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\'|'{' */
    ;

terminal fragment TEMPLATE_EXPRESSION_START
    : '{{'
    ;

terminal fragment TEMPLATE_EXPRESSION_END
    : '}}'
    ;

terminal TEMPLATE_STRING_START
    : STRING_START
      STRING_TEXT*
      TEMPLATE_EXPRESSION_START
    ;

terminal TEMPLATE_STRING_INNER
    : TEMPLATE_EXPRESSION_END
      STRING_TEXT*
      TEMPLATE_EXPRESSION_START
    ;

terminal TEMPLATE_STRING_END
    : TEMPLATE_EXPRESSION_END
      STRING_TEXT*
      STRING_END
    ;

terminal TEST_MARKER
    : '»'
    | '«'
    ;

terminal WS
    : (' '|'\t'|'\r'|'\n')+
    ;
