grammar de.unibonn.simpleml.SimpleML hidden (
	WS,
	SL_COMMENT,
	ML_COMMENT,
	TEST_MARKER
)
import 'http://www.eclipse.org/emf/2002/Ecore' as ecore
import 'http://www.unibonn.de/simpleml/SimpleML'



/**********************************************************************************************************************
 * Declarations
 **********************************************************************************************************************/

// Compilations Units --------------------------------------------------------------------------------------------------

@Exported
SmlCompilationUnit
	: {SmlCompilationUnit}
	  ('package' name=QualifiedName)?
	  imports+=SmlImport*
	  members+=SmlCompilationUnitMember*
	;

SmlImport
	: 'import' importedNamespace=QualifiedNameWithWildcard alias=SmlImportAlias?
	;

SmlImportAlias
    : 'as' name=ID
    ;

SmlCompilationUnitMember returns SmlDeclaration
	: SmlAnnotation
	| SmlClass
	| SmlEnum
	| SmlFunction
	| SmlWorkflow
	| SmlWorkflowStep
	;


// Annotations ---------------------------------------------------------------------------------------------------------

@Exported
SmlAnnotation
	: annotations+=SmlAnnotationUse*
	  modifiers+=SmlModifier*
	  'annotation' name=ID
	  parameterList=SmlParameterList?
	;

SmlAnnotationUse
	: '@' annotation=[SmlAnnotation] argumentList=SmlAnnotationUseArgumentList?
	;

SmlAnnotationUseArgumentList returns SmlArgumentList
	: {SmlArgumentList} '(' (arguments+=SmlAnnotationUseArgument (',' arguments+=SmlAnnotationUseArgument)* ','?)? ')'
	;

SmlAnnotationUseArgument returns SmlArgument
	: (parameter=[SmlParameter] '=')? value=SmlConstantExpression
	;


// Attributes ----------------------------------------------------------------------------------------------------------

@Exported
SmlAttribute
	: annotations+=SmlAnnotationUse*
	  modifiers+=SmlModifier*
	  'attr' name=ID (':' type=SmlType)?
	;


// Classes -------------------------------------------------------------------------------------------------------------

@Exported
SmlClass
	: annotations+=SmlAnnotationUse*
	  modifiers+=SmlModifier*
	  'class'
	  name=ID
	  typeParameterList=SmlTypeParameterList?
	  constructor=SmlConstructor?
	  parentTypeList=SmlParentTypeList?
	  typeParameterConstraintList=SmlTypeParameterConstraintList?
	  body=SmlClassBody?
	;

SmlConstructor
	: 'constructor' parameterList=SmlParameterList
	;

SmlParentTypeList
	: 'sub' parentTypes+=SmlParentType (',' parentTypes+=SmlParentType)* ','?
	;

SmlParentType returns SmlType
	: SmlParentPrimaryType =>({SmlMemberType.receiver=current} '.' member=SmlNamedType)*
	;

SmlParentPrimaryType returns SmlType
	: SmlNamedType
	| SmlParentParenthesizedType
	;

SmlParentParenthesizedType returns SmlParenthesizedType
    : '(' type=SmlParentType ')'
    ;

SmlClassBody
	: {SmlClassBody} '{' members+=SmlClassMember* '}'
	;

SmlClassMember returns SmlDeclaration
	: SmlAttribute
	| SmlClass
	| SmlEnum
	| SmlFunction
	;


// Enums ---------------------------------------------------------------------------------------------------------------

@Exported
SmlEnum
	: annotations+=SmlAnnotationUse*
	  modifiers+=SmlModifier*
	  'enum' name=ID
	  body=SmlEnumBody?
	;

SmlEnumBody
	: {SmlEnumBody} '{' (instances+=SmlEnumInstance (',' instances+=SmlEnumInstance)* ','?)? '}'
	;

@Exported
SmlEnumInstance
	: annotations+=SmlAnnotationUse*
	  modifiers+=SmlModifier*
      name=ID
      parameterList=SmlParameterList?
	;


// Functions -----------------------------------------------------------------------------------------------------------

@Exported
SmlFunction
	: annotations+=SmlAnnotationUse*
	  modifiers+=SmlModifier*
	  'fun'
	  name=ID
	  typeParameterList=SmlTypeParameterList?
	  parameterList=SmlParameterList
	  resultList=SmlResultList?
	  typeParameterConstraintList=SmlTypeParameterConstraintList?
	;


// Parameters ----------------------------------------------------------------------------------------------------------

SmlParameterList
	: {SmlParameterList} '(' (parameters+=SmlParameter (',' parameters+=SmlParameter)* ','?)? ')'
	;

@Exported
SmlParameter
	: annotations+=SmlAnnotationUse*
	  modifiers+=SmlModifier*
	  vararg?='vararg'?
	  name=ID (':' type=SmlType)?
	  ('or' defaultValue=SmlConstantExpression)?
	;

SmlSimpleParameterList returns SmlParameterList
	: {SmlParameterList} '(' (parameters+=SmlSimpleParameter (',' parameters+=SmlSimpleParameter)* ','?)? ')'
	;

@Exported
SmlSimpleParameter returns SmlParameter
	: name=ID (':' type=SmlType)?
	;


// Results -------------------------------------------------------------------------------------------------------------

SmlResultList
	: {SmlResultList} '->' results+=SmlResult // If there is exactly one result we need no parentheses
	| {SmlResultList} '->' '(' (results+=SmlResult (',' results+=SmlResult)* ','?)? ')'
	;

SmlResult
	: annotations+=SmlAnnotationUse*
	  modifiers+=SmlModifier*
	  name=ID (':' type=SmlType)?
	;

SmlWorkflowStepResultList returns SmlResultList
	: {SmlResultList} '->' results+=SmlWorkflowStepResult // If there is exactly one result we need no parentheses
	| {SmlResultList} '->' '(' (results+=SmlWorkflowStepResult (',' results+=SmlWorkflowStepResult)* ','?)? ')'
	;

SmlWorkflowStepResult returns SmlResult
	: name=ID (':' type=SmlType)?
	;


// Workflows -----------------------------------------------------------------------------------------------------------

SmlWorkflow
	: annotations+=SmlAnnotationUse*
	  modifiers+=SmlModifier*
	  'workflow' name=ID
	  body=SmlBlock
	;


// Workflow Steps ------------------------------------------------------------------------------------------------------

@Exported
SmlWorkflowStep
	: annotations+=SmlAnnotationUse*
	  modifiers+=SmlModifier*
	  'step'
	  name=ID
	  parameterList=SmlSimpleParameterList
	  resultList=SmlWorkflowStepResultList?
	  body=SmlBlock
	;


/**********************************************************************************************************************
 * Statements
 **********************************************************************************************************************/

// Functions and workflows --------------------------------------------------------------------------------------------

SmlBlock
	: {SmlBlock} '{' statements+=SmlStatement* '}'
	;

SmlStatement
	: SmlAssignment
	| SmlExpressionStatement
	;

SmlAssignment
	: assigneeList=SmlAssigneeList '=' expression=SmlExpression ';'
	;

SmlAssigneeList
	: {SmlAssigneeList} assignees+=SmlAssignee
	| {SmlAssigneeList} '(' (assignees+=SmlAssignee (',' assignees+=SmlAssignee)* ','?)? ')'
	;

SmlAssignee
	: {SmlPlaceholder} 'val' name=ID
	| {SmlWildcard}    '_'
	| {SmlYield}       'yield' result=[SmlResult]
	;

SmlExpressionStatement
	: expression=SmlExpression ';'
	;


// Lambdas -------------------------------------------------------------------------------------------------------------

SmlLambda
	: 'lambda'
	  parameterList=SmlSimpleParameterList?
	  body=SmlLambdaBlock
	;

SmlLambdaBlock returns SmlBlock
	: {SmlBlock} '{' statements+=SmlLambdaStatement* '}'
	;

SmlLambdaStatement returns SmlStatement
	: SmlLambdaAssignment
	| SmlExpressionStatement
	;

SmlLambdaAssignment returns SmlAssignment
	: assigneeList=SmlLambdaAssigneeList '=' expression=SmlExpression ';'
	;

SmlLambdaAssigneeList returns SmlAssigneeList
	: {SmlAssigneeList} assignees+=SmlLambdaAssignee
	| {SmlAssigneeList} '(' (assignees+=SmlLambdaAssignee (',' assignees+=SmlLambdaAssignee)* ','?)? ')'
	;

SmlLambdaAssignee returns SmlAssignee
	: {SmlPlaceholder} 'val' name=ID
	| {SmlWildcard}    '_'
	| {SmlLambdaYield} 'yield' name=ID
	;


/**********************************************************************************************************************
 * Expressions
 **********************************************************************************************************************/

SmlExpression
	: SmlOrExpression
	;

SmlOrExpression returns SmlExpression
    : SmlAndExpression ({SmlInfixOperation.leftOperand=current} operator='or' rightOperand=SmlAndExpression)*
    ;

SmlAndExpression returns SmlExpression
    : SmlNotExpression ({SmlInfixOperation.leftOperand=current} operator='and' rightOperand=SmlNotExpression)*
    ;

SmlNotExpression returns SmlExpression
    : {SmlPrefixOperation} operator='not' operand=SmlNotExpression
    | SmlEqualityExpression
    ;

SmlEqualityExpression returns SmlExpression
    : SmlComparisonExpression ({SmlInfixOperation.leftOperand=current} operator=SmlEqualityOperator rightOperand=SmlComparisonExpression)?
    ;

SmlEqualityOperator
    : '=='
    | '!='
    | '==='
    | '!=='
    ;

SmlComparisonExpression returns SmlExpression
    : SmlAdditiveExpression ({SmlInfixOperation.leftOperand=current} operator=SmlComparisonOperator rightOperand=SmlAdditiveExpression)?
    ;

SmlComparisonOperator
    : '<'
    | '<=' 
    | '>='
    | '>'
    ;

SmlAdditiveExpression returns SmlExpression
    : SmlMultiplicativeExpression ({SmlInfixOperation.leftOperand=current} operator=SmlAdditiveOperator rightOperand=SmlMultiplicativeExpression)*
    ;

SmlAdditiveOperator
    : '+'
    | '-'
    ;

SmlMultiplicativeExpression returns SmlExpression
    : SmlElvisExpression ({SmlInfixOperation.leftOperand=current} operator=SmlMultiplicativeOperator rightOperand=SmlElvisExpression)*
    ;

SmlMultiplicativeOperator
    : '*'
    | '/'
    ;

SmlElvisExpression returns SmlExpression
    : SmlUnaryOperation ({SmlInfixOperation.leftOperand=current} operator='?:' rightOperand=SmlUnaryOperation)*
    ;

SmlUnaryOperation returns SmlExpression
    : {SmlPrefixOperation} operator='-' operand=SmlUnaryOperation
    | SmlChainedExpression
    ;

SmlChainedExpression returns SmlExpression
	: SmlPrimaryExpression =>(
		  {SmlCall.receiver=current}          typeArgumentList=SmlTypeArgumentList? argumentList=SmlCallArgumentList
		| {SmlMemberAccess.receiver=current}  (nullable?='?')? '.' member=SmlReference
	)*
	;

SmlCallArgumentList returns SmlArgumentList
	: {SmlArgumentList} '(' (arguments+=SmlCallArgument (',' arguments+=SmlCallArgument)* ','?)? ')'
	;

SmlCallArgument returns SmlArgument
	: (parameter=[SmlParameter] '=')? value=SmlExpression
	;

SmlPrimaryExpression returns SmlExpression
	: SmlLambda
	| SmlLiteral
	| SmlReference
	| SmlParenthesizedExpression
	;

SmlLiteral
	: SmlBoolean
	| SmlFloat
    | SmlInt
    | SmlNull
	| SmlString
	;

SmlBoolean
    : true?='true'
    | {SmlBoolean} 'false'
    ;

SmlFloat
	: value=FLOAT
	;

SmlInt
	: value=INT
	;

SmlNull
	: {SmlNull} 'null'
	;

SmlString
	: value=STRING
	;

SmlReference
	: declaration=[SmlDeclaration]
	;

SmlParenthesizedExpression
    : '(' expression=SmlExpression ')'
    ;


/**********************************************************************************************************************
 * Constant Expressions
 **********************************************************************************************************************/

SmlConstantExpression returns SmlExpression
	: SmlLiteral
	;


/**********************************************************************************************************************
 * Modifiers
 **********************************************************************************************************************/

SmlModifier
	: 'deprecated'
	| 'open'
	| 'override'
	| 'pure'
	| 'static'
	;



/**********************************************************************************************************************
 * Names
 **********************************************************************************************************************/

QualifiedName
	: ID ('.' ID)*
	;

QualifiedNameWithWildcard
	: QualifiedName '.*'?
	;



/**********************************************************************************************************************
 * Types
 **********************************************************************************************************************/

SmlType
	: SmlPrimaryType =>({SmlMemberType.receiver=current} '.' member=SmlNamedType)*
	;

SmlPrimaryType returns SmlType
	: SmlCallableType
	| SmlNamedType
	| SmlUnionType
	| SmlParenthesizedType
	;

SmlParenthesizedType
    : '(' type=SmlType ')'
    ;

// Callable Types ------------------------------------------------------------------------------------------------------

SmlCallableType
	: 'callable'
	  parameterList=SmlParameterList
	  resultList=SmlResultList
	;


// Named Types ---------------------------------------------------------------------------------------------------------

SmlNamedType
	: declaration=[SmlNamedTypeDeclaration]
	  typeArgumentList=SmlTypeArgumentList?
	  (nullable?='?')?
	;


// Union Types ---------------------------------------------------------------------------------------------------------

SmlUnionType
	: 'union' typeArgumentList=SmlUnionTypeArgumentList
	;

SmlUnionTypeArgumentList returns SmlTypeArgumentList
	: {SmlTypeArgumentList} ('<' (typeArguments+=SmlUnionTypeArgument (',' typeArguments+=SmlUnionTypeArgument)* ','?)? '>')
	;

SmlUnionTypeArgument returns SmlTypeArgument
	: value=SmlUnionTypeArgumentValue
	;

SmlUnionTypeArgumentValue returns SmlTypeArgumentValue
	: {SmlTypeProjection} type=SmlType
	;


// Generics ------------------------------------------------------------------------------------------------------------

SmlTypeParameterList
	: {SmlTypeParameterList} ('<' (typeParameters+=SmlTypeParameter (',' typeParameters+=SmlTypeParameter)* ','?)? '>')
	;

SmlTypeParameter
	: annotations+=SmlAnnotationUse*
	  modifiers+=SmlModifier*
	  variance=SmlTypeParameterVariance?
	  name=ID
	;

SmlTypeParameterVariance
	: 'in'
	| 'out'
	;

SmlTypeParameterConstraintList
	: 'where' constraints+=SmlTypeParameterConstraint (',' constraints+=SmlTypeParameterConstraint)* ','?
	;

SmlTypeParameterConstraint
	: leftOperand=[SmlTypeParameter] operator=SmlTypeParameterConstraintOperator rightOperand=SmlType
	;

SmlTypeParameterConstraintOperator
	: 'sub'
	| 'super'
	;

SmlTypeArgumentList
	: {SmlTypeArgumentList} '<' (typeArguments+=SmlTypeArgument (',' typeArguments+=SmlTypeArgument)* ','?)? '>'
	;

SmlTypeArgument
	: (typeParameter=[SmlTypeParameter] '=')? value=SmlTypeArgumentValue
	;

SmlTypeArgumentValue
	: {SmlStarProjection} '*'
	| {SmlTypeProjection} variance=SmlTypeParameterVariance? type=SmlType
	;



/**********************************************************************************************************************
 * Terminals
 **********************************************************************************************************************/

terminal FLOAT returns ecore::EDouble
	: ('0'..'9')+ '.' ('0'..'9')+
	;

terminal ID
	: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
	;

terminal INT returns ecore::EInt
	: ('0'..'9')+
	;

terminal ML_COMMENT
	: '/*' -> '*/'
	;

terminal SL_COMMENT
	: '//' !('\n'|'\r')* ('\r'? '\n')?
	;

terminal STRING
	: '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"'
	;

terminal TEST_MARKER
	: '»'
	| '«'
	;

terminal WS
	: (' '|'\t'|'\r'|'\n')+
	;
